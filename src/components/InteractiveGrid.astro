---
interface Props {}
---

<div class="interactive-grid" id="interactive-grid" aria-hidden="true">
	<div class="interactive-grid__glow" id="grid-glow" aria-hidden="true"></div>
	<canvas id="grid-canvas" class="interactive-grid__canvas"></canvas>
	<div class="interactive-grid__static" aria-hidden="true"></div>
</div>

<style>
	.interactive-grid {
		position: fixed;
		inset: 0;
		z-index: 0;
		overflow: hidden;
		pointer-events: none;
	}

	.interactive-grid__glow {
		position: absolute;
		inset: 0;
		pointer-events: none;
		background: radial-gradient(
			circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
			rgba(45, 212, 160, var(--grid-glow-opacity, 0.15)) 0%,
			transparent 300px
		);
		opacity: var(--grid-glow, 1);
	}

	.interactive-grid__canvas {
		display: block;
		position: relative;
		width: 100%;
		height: 100%;
	}

	/* Mobile: static CSS grid only (no canvas/JS for performance) */
	.interactive-grid__static {
		display: none;
	}

	@media (max-width: 800px) {
		.interactive-grid__canvas {
			display: none;
		}

		.interactive-grid__static {
			display: block;
			position: absolute;
			inset: 0;
			/* Grid lines: same as canvas (44px, white 0.08) */
			background-image:
				linear-gradient(to right, rgba(255, 255, 255, 0.08) 1px, transparent 1px),
				linear-gradient(to bottom, rgba(255, 255, 255, 0.08) 1px, transparent 1px);
			background-size: 44px 44px;
			/* Subtle radial texture overlay */
			background-image:
				radial-gradient(
					circle at center,
					rgba(45, 212, 160, 0.03) 0%,
					transparent 70%
				),
				linear-gradient(to right, rgba(255, 255, 255, 0.08) 1px, transparent 1px),
				linear-gradient(to bottom, rgba(255, 255, 255, 0.08) 1px, transparent 1px);
			background-size: 100% 100%, 44px 44px, 44px 44px;
		}
	}
</style>

<script>
	const DECAY = 0.95;
	const GRID_LINE_WIDTH = 0.5;
	const MOBILE_BREAKPOINT = 800;
	const STORAGE_KEY = 'cl01w-control';

	function hexToRgb(hex: string): [number, number, number] {
		const m = hex.replace(/^#/, '').match(/^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
		if (!m) return [0, 26, 43];
		return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)];
	}

	function getSettings() {
		try {
			const raw = localStorage.getItem(STORAGE_KEY);
			if (raw) {
				const p = JSON.parse(raw);
				return {
					cellSize: Number(p.cellSize) || 44,
					gridOpacity: Number(p.gridOpacity) ?? 100,
					gridGlow: Number(p.gridGlow) ?? 100,
					strokeTint: Math.min(100, Math.max(0, Number(p.strokeTint) ?? 100)),
					highlightColor: p.highlightColor || '#001a2b',
					highlightOpacity: Math.min(100, Math.max(0, Number(p.highlightOpacity) ?? 20)),
				};
			}
		} catch (_) {}
		return {
			cellSize: 44,
			gridOpacity: 100,
			gridGlow: 100,
			strokeTint: 100,
			highlightColor: '#001a2b',
			highlightOpacity: 20,
		};
	}

	function init() {
		if (window.innerWidth <= MOBILE_BREAKPOINT) return;

		const gridEl = document.getElementById('interactive-grid');
		if (!gridEl) return;

		const canvas = gridEl.querySelector<HTMLCanvasElement>('#grid-canvas');
		const glowEl = gridEl.querySelector<HTMLElement>('#grid-glow');
		if (!canvas) return;

		const ctx = canvas.getContext('2d');
		if (!ctx) return;

		let settings = getSettings();
		const cellBrightness = new Map<string, number>();
		let mouseCell: { x: number; y: number } | null = null;
		let rafId: number;
		let width = 0;
		let height = 0;
		let dpr = 1;

		function setCanvasSize() {
			dpr = window.devicePixelRatio || 1;
			width = window.innerWidth;
			height = window.innerHeight;
			canvas.width = Math.round(width * dpr);
			canvas.height = Math.round(height * dpr);
			canvas.style.width = `${width}px`;
			canvas.style.height = `${height}px`;
		}

		function cellKey(x: number, y: number): string {
			return `${x},${y}`;
		}

		function draw() {
			const cellSize = settings.cellSize;
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
			ctx.globalAlpha = settings.gridOpacity / 100;

			// Stroke tint: 0 = dark gray, 100 = white (fixed alpha for visibility)
			const tint = Math.round(80 + (175 * settings.strokeTint) / 100);
			ctx.strokeStyle = `rgba(${tint}, ${tint}, ${tint}, 0.2)`;
			ctx.lineWidth = GRID_LINE_WIDTH;

			const cols = Math.ceil(width / cellSize) + 1;
			const rows = Math.ceil(height / cellSize) + 1;
			ctx.beginPath();
			for (let i = 0; i <= cols; i++) {
				const x = i * cellSize;
				ctx.moveTo(x, 0);
				ctx.lineTo(x, height);
			}
			for (let i = 0; i <= rows; i++) {
				const y = i * cellSize;
				ctx.moveTo(0, y);
				ctx.lineTo(width, y);
			}
			ctx.stroke();
			ctx.globalAlpha = 1;

			const keysToDelete: string[] = [];
			cellBrightness.forEach((value, key) => {
				const next = value * DECAY;
				if (next < 0.01) keysToDelete.push(key);
				else cellBrightness.set(key, next);
			});
			keysToDelete.forEach((k) => cellBrightness.delete(k));

			if (mouseCell !== null) {
				cellBrightness.set(cellKey(mouseCell.x, mouseCell.y), 1.0);
			}

			// Hover fill: color from picker, opacity 0–100 maps to subtle (0.01)–dramatic (0.4)
			const [hr, hg, hb] = hexToRgb(settings.highlightColor);
			const fillAlphaMax = 0.01 + (0.39 * settings.highlightOpacity) / 100;
			cellBrightness.forEach((brightness, key) => {
				if (brightness <= 0) return;
				const [x, y] = key.split(',').map(Number);
				const px = x * cellSize;
				const py = y * cellSize;
				ctx.fillStyle = `rgba(${hr}, ${hg}, ${hb}, ${fillAlphaMax * brightness})`;
				ctx.fillRect(px + 0.5, py + 0.5, cellSize - 0.5, cellSize - 0.5);
			});

			rafId = requestAnimationFrame(draw);
		}

		function onMouseMove(e: MouseEvent) {
			const x = e.clientX;
			const y = e.clientY;
			gridEl.style.setProperty('--mouse-x', `${x}px`);
			gridEl.style.setProperty('--mouse-y', `${y}px`);
			const cellSize = settings.cellSize;
			if (x >= 0 && x < width && y >= 0 && y < height) {
				mouseCell = {
					x: Math.floor(x / cellSize),
					y: Math.floor(y / cellSize),
				};
			} else {
				mouseCell = null;
			}
		}

		function onMouseLeave() {
			mouseCell = null;
		}

		function applyGlowOpacity() {
			gridEl.style.setProperty('--grid-glow', String(settings.gridGlow / 100));
			// Glow center strength: 0 = subtle, 100 = strong (0.05–0.65)
			gridEl.style.setProperty('--grid-glow-opacity', String(0.05 + (0.6 * settings.gridGlow) / 100));
		}

		window.addEventListener('cl01w-settings', ((e: CustomEvent) => {
			settings = { ...settings, ...e.detail };
			applyGlowOpacity();
		}) as EventListener);

		setCanvasSize();
		applyGlowOpacity();
		draw();

		document.addEventListener('mousemove', onMouseMove, { passive: true });
		document.addEventListener('mouseleave', onMouseLeave);

		window.addEventListener('resize', setCanvasSize);
	}

	document.addEventListener('DOMContentLoaded', init);
	window.addEventListener('resize', () => {
		if (window.innerWidth > MOBILE_BREAKPOINT) {
			const gridEl = document.querySelector('.interactive-grid');
			const canvas = gridEl?.querySelector<HTMLCanvasElement>('#grid-canvas');
			if (canvas && !canvas.width) init();
		}
	});
</script>
